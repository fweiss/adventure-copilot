# generated byt cahtgpt5

#!/usr/bin/env python3
import subprocess
import uuid
import time
import os
import select

class BashAgent:
    def __init__(self, bash_path="/bin/bash"):
        # Start a *persistent* bash with a clean environment (no rc/profile)
        self.proc = subprocess.Popen(
            [bash_path, "--noprofile", "--norc"],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1  # line-buffered
        )
        if self.proc.stdin is None or self.proc.stdout is None:
            raise RuntimeError("Failed to create pipes to bash")

    def run(self, cmd: str, timeout: float = 10.0):
        """
        Send a command string to bash and wait for completion.
        Returns (exit_code:int, output:str).

        The shell is persistent, so things like `cd` will carry over to
        subsequent calls.
        """
        if self.proc.poll() is not None:
            raise RuntimeError("Bash process is not running")

        # Unique marker to know when the command is finished and capture exit code
        marker = f"__CMD_DONE__{uuid.uuid4().hex}__"
        trailer = f'echo {marker} $?'

        # Write the command + trailer to the shell
        self.proc.stdin.write(cmd.rstrip() + "\n" + trailer + "\n")
        self.proc.stdin.flush()

        # Read until we see the marker line
        output_lines = []
        end_line = None
        deadline = time.monotonic() + timeout

        # Use select() so we can enforce a timeout without blocking indefinitely
        fd = self.proc.stdout.fileno()

        while time.monotonic() < deadline:
            r, _, _ = select.select([fd], [], [], max(0.0, deadline - time.monotonic()))
            if not r:
                continue  # timeout slice elapsed, loop again

            line = self.proc.stdout.readline()
            if not line:  # EOF
                break

            # Strip trailing newline to make processing a bit easier
            stripped = line.rstrip("\n")
            if stripped.startswith(marker + " "):
                end_line = stripped
                break
            else:
                output_lines.append(line)  # keep original with newline

        if end_line is None:
            raise TimeoutError(f"Command did not finish within {timeout} seconds")

        # Parse exit code from the marker line
        try:
            exit_code = int(end_line.split(" ", 1)[1])
        except Exception:
            exit_code = 1  # fall back if parsing fails

        return exit_code, "".join(output_lines)

    def close(self):
        if self.proc.poll() is None:
            try:
                self.proc.stdin.write("exit\n")
                self.proc.stdin.flush()
            except Exception:
                pass
            self.proc.wait(timeout=2.0)

if __name__ == "__main__":
    sh = BashAgent()
    try:
        code, out = sh.run("echo hello; uname -a")
        print("Exit:", code)
        print("Output:\n", out)

        # State persists (cd sticks for the next command)
        sh.run("mkdir -p /tmp/agent_demo && cd /tmp/agent_demo")
        code, out = sh.run('pwd; printf "file contents\\n" > note.txt; ls -l')
        print("Exit:", code)
        print("Output:\n", out)

        # Show stderr example (combined into output)
        code, out = sh.run("ls /definitely/not/here")
        print("Exit:", code)
        print("Output:\n", out)
    finally:
        sh.close()
