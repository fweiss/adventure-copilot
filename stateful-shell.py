# generated by chatgpt5

# pip install openai-agents
import asyncio, subprocess, uuid, time, select
from agents import Agent, Runner, function_tool

class BashSession:
    def __init__(self, bash="/bin/bash"):
        self.p = subprocess.Popen(
            [bash, "--noprofile", "--norc"],
            stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
            text=True, bufsize=1
        )
        if not self.p.stdin or not self.p.stdout:
            raise RuntimeError("Failed to start bash")

    def run(self, cmd: str, timeout: float = 15.0):
        if self.p.poll() is not None:
            raise RuntimeError("bash exited")
        marker = f"__DONE__{uuid.uuid4().hex}__"
        self.p.stdin.write(cmd.rstrip() + f"\necho {marker} $?\n")
        self.p.stdin.flush()

        out_lines, deadline = [], time.monotonic() + timeout
        fd = self.p.stdout.fileno()
        exit_code = None
        while time.monotonic() < deadline:
            r, _, _ = select.select([fd], [], [], max(0.0, deadline - time.monotonic()))
            if not r:
                continue
            line = self.p.stdout.readline()
            if not line:
                break
            s = line.rstrip("\n")
            if s.startswith(marker + " "):
                exit_code = int(s.split(" ", 1)[1])
                break
            out_lines.append(line)
        if exit_code is None:
            raise TimeoutError("command timed out")
        return exit_code, "".join(out_lines)

    def close(self):
        try:
            if self.p.poll() is None:
                self.p.stdin.write("exit\n"); self.p.stdin.flush()
                self.p.wait(timeout=2)
        except Exception:
            pass

bash = BashSession()

@function_tool
def bash_run(command: str) -> str:
    """Run a shell command in a persistent Bash session and return stdout/stderr and exit code.

    Args:
      command: The command string to execute (can include `cd`, exports, pipes, etc.).
    """
    code, out = bash.run(command)
    return f"<exit:{code}>\n{out}"

agent = Agent(
    name="Shell Agent",
    instructions=(
        "When you need to use the shell, call the `bash_run` tool with a single command string. "
        "Interpret the returned output and continue as needed."
    ),
    tools=[bash_run],
)

async def main():
    # Example: maintain state across multiple tool calls
    result = await Runner.run(agent, "Create /tmp/agents_demo, cd there, make hello.txt with 'hi', then show its contents.")
    print(result.final_output)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    finally:
        bash.close()
