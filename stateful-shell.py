# generated by chatgpt5

# pip install openai-agents
import asyncio, subprocess, uuid, time, select
from agents import Agent, Runner, function_tool, ItemHelpers
from openai.types.responses import ResponseTextDeltaEvent

class BashSession:
    def __init__(self, bash="/bin/bash"):
        self.p = subprocess.Popen(
            [bash, "--noprofile", "--norc"],
            stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
            text=True, bufsize=1
        )
        if not self.p.stdin or not self.p.stdout:
            raise RuntimeError("Failed to start bash")

    def run(self, cmd: str, timeout: float = 15.0):
        if self.p.poll() is not None:
            raise RuntimeError("bash exited")
        marker = f"__DONE__{uuid.uuid4().hex}__"
        self.p.stdin.write(cmd.rstrip() + f"\necho {marker} $?\n")
        self.p.stdin.flush()
        print("sent to shell {}", cmd)

        out_lines, deadline = [], time.monotonic() + timeout
        fd = self.p.stdout.fileno()
        exit_code = None
        while time.monotonic() < deadline:
            r, _, _ = select.select([fd], [], [], max(0.0, deadline - time.monotonic()))
            if not r:
                continue
            line = self.p.stdout.readline()
            if not line:
                break
            s = line.rstrip("\n")
            if s.startswith(marker + " "):
                exit_code = int(s.split(" ", 1)[1])
                break
            out_lines.append(line)
        if exit_code is None:
            raise TimeoutError("command timed out")
        return exit_code, "".join(out_lines)

    def close(self):
        try:
            if self.p.poll() is None:
                self.p.stdin.write("exit\n"); self.p.stdin.flush()
                self.p.wait(timeout=2)
        except Exception:
            pass

bash = BashSession()

@function_tool
def bash_run(command: str) -> str:
    """Run a shell command in a persistent Bash session and return stdout/stderr and exit code.

    Args:
      command: The command string to execute (can include `cd`, exports, pipes, etc.).
    """
    code, out = bash.run(command)
    return f"<exit:{code}>\n{out}"

agent = Agent(
    name="Shell Agent",
    instructions=(
        "When you need to use the shell, call the `bash_run` tool with a single command string. "
        "Interpret the returned output and continue as needed."
    ),
    tools=[bash_run],
)

async def main():
    # Example: maintain state across multiple tool calls

    prompt = "Create /tmp/agents_demo, cd there, make hello.txt with 'hi', then show its contents."
    prompt = 'list the contents of the user home directury' 
    prompt = """
        run /usr/local/cellar/open-adventure/1.20/bin/advent,
        when the program has started it prints a message and accpts input,
        enter n, and enter quit, and enter y
        provide all levels dignostics   
    """
    # result = await Runner.run(agent, "Create /tmp/agents_demo, cd there, make hello.txt with 'hi', then show its contents.")
    # print(result.final_output)

    # stream = Runner.run_streamed(agent, input="List files, then print Python version.")
    stream = Runner.run_streamed(agent, input=prompt)
    async for event in stream.stream_events():
        if event.type == "raw_response_event" and isinstance(event.data, ResponseTextDeltaEvent):
            print(event.data.delta, end="", flush=True)
        elif event.type == "run_item_stream_event" and event.item.type == "tool_call_output_item":
            print("\n[tool output]\n" + event.item.output)
       # When items are generated, print them
        elif event.type == "run_item_stream_event":
            if event.item.type == "tool_call_item":
                print("-- Tool was called")
            elif event.item.type == "tool_call_output_item":
                print(f"-- Tool output: {event.item.output}")
            elif event.item.type == "message_output_item":
                print(f"-- Message output:\n {ItemHelpers.text_message_output(event.item)}")
            else:
                pass  # Ignore other event types

if __name__ == "__main__":
    try:
        asyncio.run(main())
    finally:
        bash.close()
